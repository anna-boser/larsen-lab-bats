---
title: "Land Cover Analysis for Bat Presence"
author: "D. Nākoa Farrant"
date: "2022-10-21"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(tidyverse)
library(stars) # ʻstarsʻ requires 'sf' 0.9.8 was found, but >= 1.0.3
library(sf)
library(raster) # used to resample FVEG raster with "ngb" method
library(terra)
library(nngeo) # to remove holes from polygons
library(exactextractr) # extract bat occurrence in the land cover polygons
library(here)
```

# Read in bat study site and bat occurrence data
```{r}
# polygon with the extent of the study region
bat_study_area <- st_read(here("data/landcover_analysis/bats/bats_study_area/bats_study_area.shp")) %>% 
  st_transform(st_crs(3310)) %>% 
  st_make_valid()

# WGS84 projection of the exponentially corrected bat layer
bat_exp <- rast(here("data/aggregated_data/bats_exponential_corrected_2019.tif")) 

#bat_raw_NAD83 <- project(bat_raw, "epsg:3310")
bat_exp_NAD83 <- project(bat_exp, "epsg:3310")
```


# Read in FVEG data
```{r}
# fveg from CALFIRE FRAP
# https://map.dfg.ca.gov/metadata/ds1327.html

# read into arcmap and then exported as a tif because had trouble reading the geodatabase in R
# create a new column that is equal to WHR13NAME except where WHRNUM has riparian values: 15 (Desert Riparian), 19, 37 (Montane Riparian), 56 (Valley Foothill Riparian)
# Use the Lookup tool to export the new column as a raster and read that in here
# start using the raster package instead of terra so you can resample with nearest neighbor method
fveg_raster <- rast(here("data/landcover_analysis/fveg/fveg_whr10num_ClipBats.tif"))
```

```{r}
# resample fveg raster (30m) to the resolution of the bat data (70m) using the nearest neighbor method
# the nearest neighbor method treats the class code numbers in the FVEG raster as categorical variables
fveg_resample_ngb <- terra::resample(fveg_raster, bat_exp_NAD83, method = "near")

# convert the resampled raster to polygons in an SF object
fveg_resample_ngb_sf <- sf::as_Spatial(sf::st_as_sf(stars::st_as_stars(fveg_resample_ngb), as_points = FALSE, merge = T)) %>% 
  st_as_sf() %>% 
  st_make_valid()

st_write(fveg_resample_ngb_sf, here("data/landcover_analysis/fveg/fveg_resample_ngb_sf.gpkg"), append = F)
```

# Read in Land IQ crop data shapefile
```{r}
# Data IQ crop data from 2019 downloaded from https://data.cnra.ca.gov/dataset/statewide-crop-mapping
landIQ <- st_read(here("data/landcover_analysis/i15_Crop_Mapping_2019/i15_Crop_Mapping_2019.shp")) %>% 
  st_zm(drop = TRUE) %>% #add this because we had issues https://r-spatial.github.io/sf/reference/st_zm.html
  st_transform(st_crs(3310)) %>%  # project into NAD83 / California Albers projection
  st_make_valid()

# Crop the extent of land IQ agricultural data to bat study area
landIQ_clip2bats <- st_crop(landIQ, bat_study_area)

# Read in a CSV dictionary to add SummerCropID and CropName associated with the CROPTYP2 column in the original landIQ dataset
# SummerCropID was a code that was assigned to each CROPTYP2 arbitrarily in alphabetical order. The CropName is derived from the metadata associated with each CROPTYP2 abbreviation  
SummerCropID_crosswalk <- read_csv(here("data/landcover_analysis/CSV_files/SummerCropID.csv"))
landIQ_clip2bats_SummerCropID <- merge(landIQ_clip2bats, SummerCropID_crosswalk, by = "CROPTYP2")

# isolate a subset of columns of interest from the LandIQ data layer
landIQ_clip2bats_SummerCropID_sub <- landIQ_clip2bats_SummerCropID %>% 
  dplyr::select(UniqueID, CROPTYP2, CropName, SummerCropID)
```

```{r}
# Create a helper function to erase polygons (y) from another set of polygons (x)
st_erase <- function(x, y) st_difference(x, st_union(st_combine(y)))
```

```{r}
# took 4-5 hours to run using Apple M1 Pro chip, 16 GB, MacBook Pro 2021
fveg_WHR10_erase_landIQ <- st_erase(st_make_valid(fveg_resample_ngb_sf), st_make_valid(landIQ_clip2bats_SummerCropID_sub))

st_write(fveg_WHR10_erase_landIQ, here("data/landcover_analysis/output_layers/fveg_WHR10_erase_landIQ.gpkg"), append = F)
```

```{r}
fveg_WHR10_erase_landIQ <- st_read(here("data/landcover_analysis/output_layers/fveg_WHR10_erase_landIQ.gpkg"))
```


```{r}
fveg_WHR10_erase_landIQ <- fveg_WHR10_erase_landIQ %>% 
  rename(LC_ID = values, geometry=geom)

landIQ_LCID <- landIQ_clip2bats_SummerCropID_sub %>% 
  mutate(LC_ID = SummerCropID) %>% 
  dplyr::select(LC_ID)

fveg_landIQ_bind <- rbind(fveg_WHR10_erase_landIQ, landIQ_LCID) # Not sure this rbind is being saved

st_write(fveg_landIQ_bind, here("data/landcover_analysis/output_layers/fveg_landIQ_bind.gpkg"), delete_dsn = T)
```

```{r}
fveg_landIQ_bind <- st_read(here("data/landcover_analysis/output_layers/fveg_landIQ_bind.gpkg"))
# I think this might be reading in an obsolete file.
```

```{r}
# Read in a CSV dictionary of labels and codes for different land cover types
LC_newcode_labels <- read_csv(here("data/landcover_analysis/CSV_files/newcode_labels.csv"))

fveg_landIQ_labeled <- merge(fveg_landIQ_bind, LC_newcode_labels, by = "LC_ID")

#### This code previously worked but now terra::extract no longer seems to be able to extract multiple functions at once using the user-based function f below. We explored this even with a toy example with terra's built in data and the extract function still produces an error due to trying to extract mean and standard deviation at the same time
# 
fveg_landIQ_labeled_vect <- vect(fveg_landIQ_labeled) # Still need to assign this
# 
# # function specifying what data to extract from the bats raster
# f <- function(x, na.rm = T) {
#        c(mean=mean(x, na.rm = na.rm),
#         sd=sd(x, na.rm = na.rm)
#     )
# }
# 
# # extract the average and SD of exponentially corrected bat presence values in each NewCode category and bind it to the existing SpatVect
# extract_expBats_terra_NewCode_f <- cbind(fveg_landIQ_labeled_summ_vect, terra::extract(bat_exp_NAD83, fveg_landIQ_labeled_summ_vect, fun = f, na.rm=TRUE))
# 
# # Convert the results to a data frame
# extract_expBats_terra_NewCode_f_df <- data.frame(extract_expBats_terra_NewCode_f)

# extract total bats over each of the polygons 
extract_expBats_terra_NewCode_sum <- cbind(fveg_landIQ_labeled, terra::extract(bat_exp_NAD83, fveg_landIQ_labeled, fun = sum, na.rm=TRUE))

# convert the results into data frame
extract_expBats_terra_NewCode_sum_df <- data.frame(extract_expBats_terra_NewCode_sum)

# Rename the extracted column to be "TotalBats" instead of the generic "bats_exponential_corrected_2018"
extract_expBats_terra_NewCode_sum_df <- extract_expBats_terra_NewCode_sum_df %>% 
  rename(TotalBats = bats_exponential_corrected_2019)

```
```{r}
extract_expBats_terra_NewCode_sum_area <- extract_expBats_terra_NewCode_sum %>% 
  mutate(area_m2 = st_area(.) %>% as.numeric(), TotalBats = bats_exponential_corrected_2019) %>% 
  mutate(bats_m2 = TotalBats/area_m2)

extract_expBats_terra_NewCode_sum_area_df <- extract_expBats_terra_NewCode_sum_area %>% 
  st_drop_geometry()

# should this be an area-weighted average? that doesnʻt seem necessary
extract_expBats_terra_NewCode_sum_area_df_summary <- extract_expBats_terra_NewCode_sum_area_df %>% 
  group_by(NewClass) %>% 
  summarise(NewClass_mean = mean(bats_m2, na.rm = T), obs_count = sum(area_m2 != 0), sd = sd(bats_m2, na.rm = T), se = sd/sqrt(obs_count), NewClass_bats_95perc = 1.96*se) %>% 
  ungroup()

extract_expBats_terra_NewCode_sum_area_df[is.na(extract_expBats_terra_NewCode_sum_area_df)] <- 0

extract_expBats_terra_NewCode_sum_area_df_summary_weighted <- extract_expBats_terra_NewCode_sum_area_df %>% 
  group_by(NewClass) %>% 
  summarise(bats_m2_AW = sum(bats_m2*area_m2)/sum(area_m2), obs_count = sum(area_m2 != 0), sd_AW = sqrt(sum(area_m2 * (bats_m2 -bats_m2_AW)^2) / (sum(area_m2)*(obs_count-1)/obs_count)), se_AW = sd_AW/sqrt(obs_count), bats_m2_95perc_AW = 1.96*se_AW, NewClassArea_m2 = sum(area_m2)) %>% 
  ungroup()  

extract_expBats_overall_stats <- extract_expBats_terra_NewCode_sum_area_df %>% 
  summarise(bats_m2_AW = sum(bats_m2*area_m2)/sum(area_m2), obs_count = sum(area_m2 != 0), sd_AW = sqrt(sum(area_m2 * (bats_m2 -bats_m2_AW)^2) / (sum(area_m2)*(obs_count-1)/obs_count)), se_AW = sd_AW/sqrt(obs_count), NewClass_bats_95perc = 1.96*se_AW, bats_m2_95perc_AW = sum(area_m2)) %>% 
  ungroup() 
```

```{r}
LC_newcode_labels_simple <- LC_newcode_labels %>% 
  dplyr::select(NewClass, NewCode) %>% 
  group_by(NewClass, NewCode) %>% 
  unique() %>% 
  ungroup()
  
extract_expBats_terra_NewCode_sum_area_df_summary_weighted_labeled <- merge(extract_expBats_terra_NewCode_sum_area_df_summary_weighted, LC_newcode_labels_simple, by = "NewClass")
```


```{r}
NewCode_map <- data.frame(
  NewCode = c(10, 20, 30, 40, 50, 60, 70, 80, 101, 110, 120, 130, 140),
  NewClass = c("Miscellaneous", "Barren/Other", "Conifer", "Desert", "Hardwood", "Herbaceous", "Shrub", "Urban", "Water/Wetland", "Fruits/Nuts/Vineyards", "Row Field", "Grassland", "Rice")
)

extract_expBats_simple <- extract_expBats_terra_NewCode_sum_area_df_summary_weighted_labeled %>% 
  mutate(bats_m2_AW = NewClass_mean_AW, bats_m2_95perc_AW = NewClass_bats_95perc) %>% 
  dplyr::select(NewCode, bats_m2_AW, bats_m2_95perc_AW)

extract_merge <- merge(extract_expBats_simple, NewCode_map, by = "NewCode")
```

```{r}
# calculate number of observation in each NewCode class to be used to calculate the Standard Error and 95% confidence interval
fveg_landIQ_labeled_ObsCount_df <- fveg_landIQ_labeled %>% 
  st_drop_geometry() %>% 
  group_by(NewCode) %>% 
  summarise(obs_count = n())

extract_merge_obs <- merge(extract_merge, fveg_landIQ_labeled_ObsCount_df, by = "NewCode")

# calculate the Standard Error and 95% confidence interval
extract_merge_obs <- extract_merge_obs %>% 
  mutate(SE = SD/sqrt(obs_count), LC_95perc = 1.96*SE)
```

```{r}
# calculate the average bat prescence across land cover types to be added as a reference line on the figure
extract_merge_obs_mean <- mean(extract_merge_obs$Mean, na.rm = T) %>% round(1)
```


```{r}
group_colormap <- data.frame(
  NewCode = c(10, 20, 30, 40, 50, 60, 70, 80, 101, 110, 120, 130, 140),
  Group = c("Agriculture", "Urban/Other", "Natural", "Natural", "Natural", "Natural", "Natural", "Urban/Other", "Water", "Agriculture", "Agriculture", "Agriculture", "Agriculture")
)

cols <- c("Agriculture" = "#efb672", "Natural" = "#49be75", "Urban/Other" = "#bc5090", "Water" = "#003f5c")

extract_merge_mergecolor <- merge(extract_merge, group_colormap, by = "NewCode")
```

```{r}
view(extract_merge_mergecolor)
```


```{r}
library(ggtext)
# plot the average and the standard error
allpolys_lc_expbats_mean <- ggplot(data = extract_merge_mergecolor, aes(x = reorder(NewClass, bats_m2_AW), y = bats_m2_AW, color = Group)) + 
  geom_point() +
  geom_errorbar(aes(ymin=bats_m2_AW-bats_m2_95perc_AW, ymax=bats_m2_AW+bats_m2_95perc_AW, color = Group)) +
  geom_hline(yintercept = mean(extract_merge_mergecolor$bats_m2_AW), color = "grey40", linetype = "dashed") + 
  labs(x = "", y = "Bat Occurrences/m^(2)") +
  scale_color_manual(values = cols) +
  coord_flip() + 
  theme_bw() +
  theme(axis.title.x = element_markdown(), panel.border = element_rect(colour = "black", fill=NA, size=1), text = element_text(size=18),
        legend.title = element_blank(),
    legend.position = c(0.8, 0.2),
           legend.key.size = unit(1, "lines"),
    legend.spacing.y = unit(0, "pt"),
    legend.background = element_blank(),
    #legend.position="bottom",
    #legend.justification = "right",
    legend.box.background = element_rect(size=0.5, linetype="solid", 
                                  colour ="black"))

allpolys_lc_expbats_mean
```



# Supplementary figures
```{r}
fveg_landIQ_labeled_area <- fveg_landIQ_labeled
fveg_landIQ_labeled_area$area_m2 <- st_area(fveg_landIQ_labeled_area) %>% as.numeric()
fveg_landIQ_labeled_area <- fveg_landIQ_labeled_area %>%  mutate(area_ha = area_m2/1e4)

fveg_landIQ_labeled_area_df <- fveg_landIQ_labeled_area %>% 
  st_drop_geometry() %>% 
  group_by(NewCode) %>% 
  summarise(MeanClassAreaHa = mean(area_ha, na.rm = T), ClassAreaHa = sum(area_ha, na.rm = T), SD_AreaHa = sd(area_ha, na.rm = T))

area_merge <- merge(fveg_landIQ_labeled_area_df, NewCode_map, by = "NewCode")

area_merge_obs <- merge(area_merge, fveg_landIQ_labeled_ObsCount_df, by = "NewCode")

# calculate the Standard Error and 95% confidence interval
area_merge_obs <- area_merge_obs %>% 
  mutate(SE = SD_AreaHa/sqrt(obs_count), LC_95perc = 1.96*SE)
```

```{r}
area_merge_obs_mergecolor <- merge(area_merge_obs, group_colormap, by = "NewCode")
```


```{r}
# plot the total area for each of the land cover classes
total_area_merge_obs_p <- ggplot(data = area_merge_obs_mergecolor, aes(x = reorder(NewClass, ClassAreaHa), y = ClassAreaHa, fill = Group)) +
  geom_col() + 
  coord_flip() +
  labs(x = "Land Cover", y = "Total Area of Land Cover Classes (ha)") +
  scale_fill_manual(values = cols) +
  theme_bw() +
  theme(
        panel.border = element_rect(colour = "black", fill=NA, size=1), text = element_text(size=18),
        legend.title = element_blank(),
    legend.position = c(0.8, 0.2),
           legend.key.size = unit(1, "lines"),
    legend.spacing.y = unit(0, "pt"),
    legend.background = element_blank(),
    #legend.position="bottom",
    #legend.justification = "right",
    legend.box.background = element_rect(size=0.5, linetype="solid", 
                                  colour ="black"))

total_area_merge_obs_p

mean_area_merge_obs_p <- ggplot(data = area_merge_obs_mergecolor, aes(x = reorder(NewClass, MeanClassAreaHa), y = MeanClassAreaHa, color = Group)) +
  geom_point() + 
  geom_errorbar(aes(ymin=MeanClassAreaHa-LC_95perc, ymax=MeanClassAreaHa+LC_95perc, color = Group)) +
  coord_flip() +
  labs(x = "Land Cover", y = "Area of Land Cover Parcels (ha)") +
  scale_color_manual(values = cols) +
  theme_bw() +
  theme(panel.border = element_rect(colour = "black", fill=NA, size=1), text = element_text(size=18),
        legend.title = element_blank(),
    legend.position = c(0.8, 0.2),
           legend.key.size = unit(1, "lines"),
    legend.spacing.y = unit(0, "pt"),
    legend.background = element_blank(),
    #legend.position="bottom",
    #legend.justification = "right",
    legend.box.background = element_rect(size=0.5, linetype="solid", 
                                  colour ="black"))

mean_area_merge_obs_p

parcel_count_merge_obs_p <- ggplot(data = area_merge_obs_mergecolor, aes(x = reorder(NewClass, obs_count), y = obs_count, color = Group)) +
  geom_point() + 
  coord_flip() +
  labs(x = "Land Cover", y = "Number of Parcels in Land Cover Class") +
  scale_color_manual(values = cols) +
  theme_bw() +
  theme(panel.border = element_rect(colour = "black", fill=NA, size=1), text = element_text(size=18),
        legend.title = element_blank(),
    legend.position = c(0.8, 0.2),
           legend.key.size = unit(1, "lines"),
    legend.spacing.y = unit(0, "pt"),
    legend.background = element_blank(),
    #legend.position="bottom",
    #legend.justification = "right",
    legend.box.background = element_rect(size=0.5, linetype="solid", 
                                  colour ="black"))

parcel_count_merge_obs_p
```

# The below code creates two scatter plots that we may not even include as supplementary figures
```{r}
fveg_landIQ_labeled_vect <- vect(fveg_landIQ_labeled)


# As noted earlier, terra::extract no longer is able to extract two functions (mean and sd) at the same time to our knowledge
# # function specifying what data to extract from the bats raster
# f <- function(x, na.rm = T) {
#        c(mean=mean(x, na.rm = na.rm),
#         sd=sd(x, na.rm = na.rm)
#     )
# }
# 
# # extract the average and SD of exponentially corrected bat presence values in each NewCode category and bind it to the existing SpatVect
# extract_expBats_terra_NewCode_allParcels <- cbind(fveg_landIQ_labeled_vect, terra::extract(bat_exp_NAD83, fveg_landIQ_labeled_vect, fun = f, na.rm=TRUE))

# So now we extract the mean and sd separately
extract_expBats_terra_NewCode_allParcels_mean <- cbind(fveg_landIQ_labeled_vect, terra::extract(bat_exp_NAD83, fveg_landIQ_labeled_vect, fun = mean, na.rm=TRUE))

extract_expBats_terra_NewCode_allParcels_sd <- cbind(fveg_landIQ_labeled_vect, terra::extract(bat_exp_NAD83, fveg_landIQ_labeled_vect, fun = sd, na.rm=TRUE))

# Convert the result from extracting the mean to an SF object
extract_expBats_terra_NewCode_allParcels_mean_sf <- st_as_sf(extract_expBats_terra_NewCode_allParcels_mean)

# Update the name of the extracted data column to be "Mean"
extract_expBats_terra_NewCode_allParcels_mean_sf <- extract_expBats_terra_NewCode_allParcels_mean_sf %>% 
  rename(Mean = bats_exponential_corrected_2018_postprocess)

# add columns for the area (in sq. meters and hectares) of each parcel that bat data was extracted within
extract_expBats_terra_NewCode_allParcels_mean_sf$area_m2 <- st_area(extract_expBats_terra_NewCode_allParcels_mean_sf) %>% as.numeric()
extract_expBats_terra_NewCode_allParcels_mean_sf <- extract_expBats_terra_NewCode_allParcels_mean_sf %>%  mutate(area_ha = round(area_m2/1e4, 2))

# Convert the results to a data frame
extract_expBats_terra_NewCode_allParcels_mean_df <- extract_expBats_terra_NewCode_allParcels_mean_sf %>% 
  st_drop_geometry()

# Convert the result from extracting the std. deviation to be a data frame
extract_expBats_terra_NewCode_allParcels_sd_df <- as.data.frame(extract_expBats_terra_NewCode_allParcels_sd)

# Update the name of the extracted column to be "SD" instead of the generic raster name
extract_expBats_terra_NewCode_allParcels_sd_df <- extract_expBats_terra_NewCode_allParcels_sd_df %>% 
  rename(SD = bats_exponential_corrected_2018_postprocess)

# merge the data frames into one
extract_expBats_terra_NewCode_allParcels_df <- merge(extract_expBats_terra_NewCode_allParcels_mean_df, extract_expBats_terra_NewCode_allParcels_sd_df, by = c("ID", "LC_ID", "NewCode", "NewClass", "WHR10NAME"))
```

```{r}
extract_expBats_terra_NewCode_allParcels_mean_mergecolor <- merge(extract_expBats_terra_NewCode_allParcels_df, group_colormap, by = "NewCode")

extract_expBats_terra_NewCode_allParcels_mean_mergecolor$Group <- factor(extract_expBats_terra_NewCode_allParcels_mean_mergecolor$Group, levels = c("Agriculture", "Natural", "Urban/Other", "Water"))

extract_expBats_terra_NewCode_allParcels_mean_mergecolor$NewClass_factor <- factor(extract_expBats_terra_NewCode_allParcels_mean_mergecolor$NewClass, levels = c("Fruits/Nuts/Vineyards", "Row_Field", "Grassland", "Rice", "Other Agriculture", "Conifer", "Hardwood", "Shrub", "Herbaceous", "Desert", "Barren/Other", "Urban", "Water/Wetland"))
```

```{r}
# calculate the average bat presence across all land cover types
extract_expBats_terra_NewCode_allParcels_mean <- mean(extract_expBats_terra_NewCode_allParcels_df$Mean, na.rm = T) %>% round(1)

# calculate the average bat presence across within land cover type
extract_expBats_terra_NewCode_allParcels_df_summ <- extract_expBats_terra_NewCode_allParcels_mean_mergecolor %>% 
  group_by(NewClass_factor, Group) %>% 
  summarise(mean = mean(Mean, na.rm = T))
```

```{r}
bats_area_scatter <- ggplot(data = extract_expBats_terra_NewCode_allParcels_mean_mergecolor, aes(x = area_ha, y = Mean, color = Group)) +
  geom_point() +
  geom_hline(yintercept = extract_expBats_terra_NewCode_allParcels_mean, color = "grey40", linetype = "dashed") + 
  labs(x = "Parcel Area (ha)", y = "Bat Presence") +
  scale_color_manual(values = cols) +
  theme_bw() +
  theme(panel.border = element_rect(colour = "black", fill=NA, size=1), text = element_text(size=18),
        legend.title = element_blank(),
    legend.position = c(0.8, 0.8),
           legend.key.size = unit(1, "lines"),
    legend.spacing.y = unit(0, "pt"),
    legend.background = element_blank(),
    #legend.position="bottom",
    #legend.justification = "right",
    legend.box.background = element_rect(size=0.5, linetype="solid", 
                                  colour ="black"))

bats_area_scatter


bats_area_scatter_lc_facet <- ggplot() +
  geom_point(data = extract_expBats_terra_NewCode_allParcels_mean_mergecolor, aes(x = area_ha, y = Mean, color = Group)) +
  geom_hline(data = extract_expBats_terra_NewCode_allParcels_df_summ, aes(yintercept = mean, color = Group), color = "grey40", linetype = "dashed") + 
  facet_wrap(~NewClass_factor) +
  labs(x = "Parcel Area (ha)", y = "Bat Presence") +
  scale_color_manual(values = cols) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 60, hjust = 1),
        panel.border = element_rect(colour = "black", fill=NA, size=1),
        legend.title = element_blank(),
           legend.key.size = unit(1, "lines"),
    legend.spacing.y = unit(0, "pt"),
    legend.background = element_blank(),
    #legend.position="bottom",
    #legend.justification = "right",
    legend.box.background = element_rect(size=0.5, linetype="solid", 
                                  colour ="black"))

bats_area_scatter_lc_facet
```