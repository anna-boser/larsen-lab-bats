summarise(tot_area_ha = sum(area_m2)/1e4)
lc_summ <- lc_label_sf %>%
st_drop_geometry() %>%
group_by(NewClass) %>%
summarise(tot_area_ha = sum(area_m2)/1e4 %>% round(1))
lc_old_summ <- lc_old_label_sf %>%
st_drop_geometry() %>%
group_by(NewClass) %>%
summarise(tot_area_ha = sum(area_m2)/1e4)
View(lc_summ)
lc_summ <- lc_label_sf %>%
st_drop_geometry() %>%
group_by(NewClass) %>%
summarise(tot_area_ha = round(sum(area_m2)/1e4, 1))
lc_old_summ <- lc_old_label_sf %>%
st_drop_geometry() %>%
group_by(NewClass) %>%
summarise(tot_area_ha = sum(area_m2)/1e4)
lc_summ <- lc_label_sf %>%
st_drop_geometry() %>%
group_by(NewClass) %>%
summarise(tot_area_ha = round(sum(area_m2)/1e4, 0))
lc_old_summ <- lc_old_label_sf %>%
st_drop_geometry() %>%
group_by(NewClass) %>%
summarise(tot_area_ha = round(sum(area_m2)/1e4, 0))
lc_summ <- lc_label_sf %>%
st_drop_geometry() %>%
group_by(NewClass) %>%
summarise(tot_area_ha = round(sum(area_m2)/1e4, 0))
lc_old_summ <- lc_old_label_sf %>%
st_drop_geometry() %>%
group_by(NewClass) %>%
summarise(old_tot_area_ha = round(sum(area_m2)/1e4, 0))
lc_check_merge <- merge(lc_old_summ, lc_summ, by = "NewClass")
View(lc_check_merge)
lc_check_merge <- lc_check_merge %>%
mutate(diff_hectare = lc_summ - lc_old_summ)
lc_summ <- lc_label_sf %>%
st_drop_geometry() %>%
group_by(NewClass) %>%
summarise(tot_area_ha = round(sum(area_m2)/1e4, 0) %>% as.numeric())
lc_old_summ <- lc_old_label_sf %>%
st_drop_geometry() %>%
group_by(NewClass) %>%
summarise(old_tot_area_ha = round(sum(area_m2)/1e4, 0) %>% as.numeric())
lc_check_merge <- merge(lc_old_summ, lc_summ, by = "NewClass")
lc_check_merge <- lc_check_merge %>%
mutate(diff_hectare = lc_summ - lc_old_summ)
lc_summ <- lc_label_sf %>%
st_drop_geometry() %>%
group_by(NewClass) %>%
summarise(tot_area_ha = round(sum(area_m2)/1e4, 0) %>% as.numeric())
lc_old_summ <- lc_old_label_sf %>%
st_drop_geometry() %>%
group_by(NewClass) %>%
summarise(mask_tot_area_ha = round(sum(area_m2)/1e4, 0) %>% as.numeric())
lc_check_merge <- merge(lc_old_summ, lc_summ, by = "NewClass")
lc_check_merge <- lc_check_merge %>%
mutate(diff_hectare = tot_area_ha - mask_tot_area_ha)
lc_summ <- lc_label_sf %>%
st_drop_geometry() %>%
group_by(NewClass) %>%
summarise(NoMask_tot_area_ha = round(sum(area_m2)/1e4, 0) %>% as.numeric())
lc_old_summ <- lc_old_label_sf %>%
st_drop_geometry() %>%
group_by(NewClass) %>%
summarise(mask_tot_area_ha = round(sum(area_m2)/1e4, 0) %>% as.numeric())
lc_check_merge <- merge(lc_old_summ, lc_summ, by = "NewClass")
lc_check_merge <- lc_check_merge %>%
mutate(diff_hectare = NoMask_tot_area_ha - mask_tot_area_ha)
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(stars) # ʻstarsʻ requires 'sf' 0.9.8 was found, but >= 1.0.3
library(sf)
library(terra)
library(exactextractr)
# fveg from CALFIRE FRAP
# https://map.dfg.ca.gov/metadata/ds1327.html
# read into arcmap and then exported as a tif because had trouble reading the geodatabase in R
# create a new column that is equal to WHR13NAME except where WHRNUM has riparian values: 15 (Desert Riparian), 19, 37 (Montane Riparian), 56 (Valley Foothill Riparian)
# Use the Lookup tool to export the new column as a raster and read that in here
fveg <- rast("~/Documents/github/larsen-lab-bats/data/landcover_analysis/fveg/fveg_ReclassVegCode_NAD83.tif")
poly_fveg <- as.polygons(fveg, values = TRUE,extent=FALSE) # this converts it to a SpatVect
fveg_sf <- sf::as_Spatial(sf::st_as_sf(stars::st_as_stars(fveg), as_points = FALSE, merge = T)) %>%
st_as_sf() %>%
st_make_valid()
fveg_sf$IQ_check <- sf::st_intersects(fveg_sf, landIQ, sparse = F)
# Data IQ crop data from 2019 downloaded from https://data.cnra.ca.gov/dataset/statewide-crop-mapping
landIQ <- st_read("~/Documents/github/larsen-lab-bats/data/landcover_analysis/i15_Crop_Mapping_2019/i15_Crop_Mapping_2019.shp") %>%
st_transform(st_crs(3310)) %>%  # project into NAD83 / California Albers projection
st_make_valid()
fveg_sf$IQ_check <- ifelse(sf::st_intersects(fveg_sf, landIQ, sparse = F),
"Yes",
"No")
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(stars) # ʻstarsʻ requires 'sf' 0.9.8 was found, but >= 1.0.3
library(sf)
library(terra)
library(exactextractr)
# fveg from CALFIRE FRAP
# https://map.dfg.ca.gov/metadata/ds1327.html
# read into arcmap and then exported as a tif because had trouble reading the geodatabase in R
# create a new column that is equal to WHR13NAME except where WHRNUM has riparian values: 15 (Desert Riparian), 19, 37 (Montane Riparian), 56 (Valley Foothill Riparian)
# Use the Lookup tool to export the new column as a raster and read that in here
fveg <- rast("~/Documents/github/larsen-lab-bats/data/landcover_analysis/fveg/fveg_ReclassVegCode_NAD83.tif")
fveg_vect <- as.polygons(fveg, values = TRUE,extent=FALSE) # this converts it to a SpatVect
# Data IQ crop data from 2019 downloaded from https://data.cnra.ca.gov/dataset/statewide-crop-mapping
landIQ <- st_read("~/Documents/github/larsen-lab-bats/data/landcover_analysis/i15_Crop_Mapping_2019/i15_Crop_Mapping_2019.shp") %>%
st_transform(st_crs(3310)) %>%  # project into NAD83 / California Albers projection
st_make_valid()
landIQ_vect <- vect(landIQ)
landIQ_vect <- vect(landIQ)
fveg_landIQ_intersects <- relate(fveg_vect, landIQ_vect, "intersects")
fveg_vet$IQ_check <- ifelse(relate(fveg_vect, landIQ_vect, "intersects"), "Yes", "No")
fveg_vect$IQ_check <- ifelse(relate(fveg_vect, landIQ_vect, "intersects"), "Yes", "No")
fveg_sf <- st_as_sf(fveg_vect)
fveg_sf_summarise <- fveg_sf %>%
group_by(IQ_check) %>%
summarise()
View(fveg_sf_summarise)
IQ_check <- relate(fveg_vect, landIQ_vect, "intersects")
View(IQ_check)
landIQ_clip2bats_SummerCropID_buff <- st_buffer(landIQ_clip2bats_SummerCropID, 50)
# Crop to bat study area
landIQ_clip2bats <- st_crop(landIQ, bat_study_area)
bat_study_area <- st_read("~/Documents/github/larsen-lab-bats/data/landcover_analysis/bats/bats_study_area/bats_study_area.shp") %>%
st_transform(st_crs(3310)) %>%
st_make_valid()
bat_raw <- rast("~/Documents/github/larsen-lab-bats/data/landcover_analysis/bats/2017_aggregate_2017.tif") # WGS84 projection of the raw bats
bat_exp <- rast("~/Documents/github/larsen-lab-bats/data/landcover_analysis/bats/bats_exponential_corrected_2017.tif") # WGS84 projection of the exponentially corrected bat layer
# Crop to bat study area
landIQ_clip2bats <- st_crop(landIQ, bat_study_area)
# Alternative code that does the same as the above chunk, just slightly slower and also adds a CropName column
SummerCropID_crosswalk <- read_csv("~/Documents/github/larsen-lab-bats/data/landcover_analysis/CSV_files/SummerCropID.csv")
landIQ_clip2bats_SummerCropID <- merge(landIQ_clip2bats, SummerCropID_crosswalk, by = "CROPTYP2")
landIQ_clip2bats_SummerCropID_buff <- st_buffer(landIQ_clip2bats_SummerCropID, 50)
st_write(landIQ_clip2bats_SummerCropID_buff, "~/Documents/github/larsen-lab-bats/data/landcover_analysis/output_layers/landIQ_clip2bats_SummerCropID_buff.gpkg", overwrite = T)
writeVector(fveg_vect, "~/Documents/github/larsen-lab-bats/data/landcover_analysis/output_layers/fveg_vect.gpkg")
writeVector(fveg_vect, "~/Documents/github/larsen-lab-bats/data/landcover_analysis/output_layers/fveg_vect.shp")
writeVector(fveg_vect, "fveg_vect.shp")
writeVector(landIQ_vect, "~/Documents/github/larsen-lab-bats/data/landcover_analysis/output_layers/landIQ_vect.shp")
writeVector(fveg_vect, "fveg_vect.gpkg")
writeVector(landIQ_vect, "~/Documents/github/larsen-lab-bats/data/landcover_analysis/output_layers/landIQ_vect.shp")
getwd()
IQ_check_df <- IQ_check %>% as.data.frame()
IQ_check_df <- IQ_check %>% as.data.frame() %>%
tibble::rownames_to_column("FVEG_class")
IQ_check_summ <- IQ_check_df  %>%
group_by(FVEG_class) %>%
summarise()
View(IQ_check_summ)
summary(IQ_check_df %>% as.factor())
View(fveg_sf_summarise)
fveg$IQ_check <- ifelse(relate(fveg_vect, landIQ_vect, "intersects"),
"Yes",
"No")
fveg_sf <- st_as_sf(fveg_vect)
fveg_sf_summarise <- fveg_sf %>%
group_by(IQ_check) %>%
summarise() # all of the polygons supposedly donʻt intersect with landIQ
View(fveg_sf_summarise)
View(fveg_sf)
fveg_df <- fveg_sf %>%
st_drop_geometry()
View(fveg_df)
IQ_check[1,]
IQ_check[2,]
x <- matrix(1:4,ncol=2)
x[1,]
View(x)
fveg_sf <- sf::as_Spatial(sf::st_as_sf(stars::st_as_stars(fveg), as_points = FALSE, merge = T)) %>%
st_as_sf() %>%
st_make_valid()
View(fveg_sf)
fveg_row1check <- fveg_sf %>%
filter(st_intersects(., landIQ, sparse = FALSE)[1,])
fveg_row1check <- fveg_sf %>%
filter(relate(., landIQ, "intersects")[1,])
fveg_row1check <- fveg_vect %>%
filter(relate(., landIQ_vect, "intersects")[1,])
true_row1 <- filter(IQ_check[1,] == TRUE)
true_row1 <- filter(IQ_check[1,])
class(IQ_check)
row1 <- IQ_check[1,]
true_row1 <- filter(row1)
row1 <- IQ_check[1,]
row1_adj <- ifelse(row1 == TRUE, "Yes", "No")
true_row1 <- filter(row1)
row1 <- IQ_check[1,]
row1_adj <- ifelse(row1 == TRUE, "Yes", "No")
true_row1 <- filter(row1_adj)
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(stars) # ʻstarsʻ requires 'sf' 0.9.8 was found, but >= 1.0.3
library(sf)
library(terra)
library(exactextractr)
# fveg from CALFIRE FRAP
# https://map.dfg.ca.gov/metadata/ds1327.html
# read into arcmap and then exported as a tif because had trouble reading the geodatabase in R
# create a new column that is equal to WHR13NAME except where WHRNUM has riparian values: 15 (Desert Riparian), 19, 37 (Montane Riparian), 56 (Valley Foothill Riparian)
# Use the Lookup tool to export the new column as a raster and read that in here
fveg <- rast("~/Documents/github/larsen-lab-bats/data/landcover_analysis/fveg/fveg_ReclassVegCode_NAD83.tif")
# Data IQ crop data from 2019 downloaded from https://data.cnra.ca.gov/dataset/statewide-crop-mapping
landIQ <- st_read("~/Documents/github/larsen-lab-bats/data/landcover_analysis/i15_Crop_Mapping_2019/i15_Crop_Mapping_2019.shp") %>%
st_transform(st_crs(3310)) %>%  # project into NAD83 / California Albers projection
st_make_valid()
landIQ_vect <- vect(landIQ)
x <- rbind(c(-10,0), c(140,60), c(160,0), c(140,-55))
hole <- rbind(c(80,0), c(105,13), c(120,2), c(105,-13))
z <- rbind(cbind(object=1, part=1, x, hole=0),
cbind(object=1, part=1, hole, hole=1))
colnames(z)[3:4] <- c('x', 'y')
p <- vect(z, "polygons", atts=data.frame(id=1))
p
f <- fillHoles(p)
g <- fillHoles(p, inverse=TRUE)
plot(p, lwd=16, border="gray", col="light yellow")
polys(f, border="blue", lwd=3, density=4, col="orange")
polys(g, col="white", lwd=3)
x <- rbind(c(-10,0), c(140,60), c(160,0), c(140,-55))
hole <- rbind(c(80,0), c(105,13), c(120,2), c(105,-13))
z <- rbind(cbind(object=1, part=1, x, hole=0),
cbind(object=1, part=1, hole, hole=1))
colnames(z)[3:4] <- c('x', 'y')
p <- vect(z, "polygons", atts=data.frame(id=1))
p
f <- fillHoles(p)
g <- fillHoles(p, inverse=TRUE)
plot(p, lwd=16, border="gray", col="light yellow")
polys(f, border="blue", lwd=3, density=4, col="orange")
#polys(g, col="white", lwd=3)
x <- rbind(c(-10,0), c(140,60), c(160,0), c(140,-55))
hole <- rbind(c(80,0), c(105,13), c(120,2), c(105,-13))
z <- rbind(cbind(object=1, part=1, x, hole=0),
cbind(object=1, part=1, hole, hole=1))
colnames(z)[3:4] <- c('x', 'y')
p <- vect(z, "polygons", atts=data.frame(id=1))
p
f <- fillHoles(p)
g <- fillHoles(p, inverse=TRUE)
plot(p, lwd=16, border="gray", col="light yellow")
#polys(f, border="blue", lwd=3, density=4, col="orange")
#polys(g, col="white", lwd=3)
x <- rbind(c(-10,0), c(140,60), c(160,0), c(140,-55))
hole <- rbind(c(80,0), c(105,13), c(120,2), c(105,-13))
z <- rbind(cbind(object=1, part=1, x, hole=0),
cbind(object=1, part=1, hole, hole=1))
colnames(z)[3:4] <- c('x', 'y')
p <- vect(z, "polygons", atts=data.frame(id=1))
p
f <- fillHoles(p)
g <- fillHoles(p, inverse=TRUE)
plot(p, lwd=16, border="gray", col="light yellow")
polys(f, border="blue", col="orange")
#polys(g, col="white", lwd=3)
bat_study_area <- st_read("~/Documents/github/larsen-lab-bats/data/landcover_analysis/bats/bats_study_area/bats_study_area.shp") %>%
st_transform(st_crs(3310)) %>%
st_make_valid()
bat_raw <- rast("~/Documents/github/larsen-lab-bats/data/landcover_analysis/bats/2017_aggregate_2017.tif") # WGS84 projection of the raw bats
bat_exp <- rast("~/Documents/github/larsen-lab-bats/data/landcover_analysis/bats/bats_exponential_corrected_2017.tif") # WGS84 projection of the exponentially corrected bat layer
install.packages("albersusa")
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(stars) # ʻstarsʻ requires 'sf' 0.9.8 was found, but >= 1.0.3
library(sf)
library(terra)
library(exactextractr)
library(albersusa)
install.packages("albersusa")
download.file("https://drive.google.com/uc?export=download&id=1Iyk7XhPHY5rs4OLI56b3GHibZIPdDnpo",
destfile = "Areas.zip",
mode = "wb"
)
unzip("Areas.zip", exdir = ".")
Areas <- st_read("Areas.gpkg")
#> Simple feature collection with 6 features and 1 field
#> Geometry type: MULTIPOLYGON
#> Dimension:     XY
#> Bounding box:  xmin: 272036.8 ymin: 432143.8 xmax: 288261.8 ymax: 446143.8
#> Projected CRS: OSGB 1936 / British National Grid
Area_1 <- Areas %>%
filter(name == "Area 1")
# Use concaveman
library(concaveman)
geom_convex <- concaveman(st_coordinates(Area_1)[, 1:2]) %>%
list() %>%
st_polygon() %>%
st_sfc()
Area_convex <- st_sf(st_drop_geometry(Area_1),
geom = geom_convex,
crs = st_crs(Areas)
)
plot(st_geometry(Area_convex), col = "red")
plot(st_geometry(Area_1), add = TRUE, border = "blue")
Area_1_simple <- Area_1 %>%
st_simplify(TRUE, dTolerance = 5000) %>%
st_cast("MULTIPOLYGON") %>%
st_coordinates()
# Data IQ crop data from 2019 downloaded from https://data.cnra.ca.gov/dataset/statewide-crop-mapping
landIQ <- st_read("~/Documents/github/larsen-lab-bats/data/landcover_analysis/i15_Crop_Mapping_2019/i15_Crop_Mapping_2019.shp") %>%
st_transform(st_crs(3310)) %>%  # project into NAD83 / California Albers projection
st_make_valid()
landIQ_4326 <- landIQ %>%
st_transform(st_crs(4326))
landIQ_simple <- landIQ %>%
st_simplify(TRUE, dTolerance = 5000) %>%
st_cast("MULTIPOLYGON") %>%
st_coordinates()
library(concaveman)
geom_convex <- concaveman(landIQ_simple) %>%
list() %>%
st_polygon() %>%
st_sfc()
View(Area_1_simple)
landIQ_points <- st_as_sf(landIQ_simple, coords = c("X","Y"), remove = FALSE)
landIQ_points <- st_as_sf(landIQ_simple %>% as.data.frame(), coords = c("X","Y"), remove = FALSE)
View(landIQ_points)
library(concaveman)
geom_convex <- concaveman(landIQ_points$geometry) %>%
list() %>%
st_polygon() %>%
st_sfc()
data(points)
force(points)
View(points)
class(points)
library(concaveman)
geom_convex <- concaveman(landIQ_points$geometry) %>%
list() %>%
st_polygon() %>%
st_sfc()
library(concaveman)
geom_convex <- concaveman(points) %>%
list() %>%
st_polygon() %>%
st_sfc()
library(concaveman)
geom_convex <- concaveman(points)
Area_convex <- st_sf(st_drop_geometry(landIQ_points),
geom = geom_convex,
crs = st_crs(4326)
)
library(concaveman)
geom_convex <- concaveman(landIQ_points)
Area_convex <- st_sf(st_drop_geometry(landIQ_points),
geom = geom_convex,
crs = st_crs(4326)
)
View(geom_convex)
ggplot() +
geom_sf(data = geom_convex)
# Crop to bat study area
landIQ_clip2bats <- st_crop(landIQ, bat_study_area)
bat_study_area <- st_read("~/Documents/github/larsen-lab-bats/data/landcover_analysis/bats/bats_study_area/bats_study_area.shp") %>%
st_transform(st_crs(3310)) %>%
st_make_valid()
bat_raw <- rast("~/Documents/github/larsen-lab-bats/data/landcover_analysis/bats/2017_aggregate_2017.tif") # WGS84 projection of the raw bats
bat_exp <- rast("~/Documents/github/larsen-lab-bats/data/landcover_analysis/bats/bats_exponential_corrected_2017.tif") # WGS84 projection of the exponentially corrected bat layer
# Crop to bat study area
landIQ_clip2bats <- st_crop(landIQ, bat_study_area)
landIQ_clip2bats_4326 <- landIQ_clip2bats %>%
st_transform(st_crs(4326))
landIQ_clip2bats_4326_simple <- landIQ_clip2bats_4326 %>%
st_simplify(TRUE, dTolerance = 5000) %>%
st_cast("MULTIPOLYGON") %>%
st_coordinates()
landIQ_clip2bats_4326_simple <- landIQ_clip2bats_4326 %>%
st_simplify(TRUE) %>%
st_cast("MULTIPOLYGON") %>%
st_coordinates()
landIQ_clip2bats_4326_points <- st_as_sf(landIQ_clip2bats_4326_simple %>% as.data.frame(), coords = c("X","Y"), remove = FALSE)
library(concaveman)
geom_convex <- concaveman(landIQ_clip2bats_4326_points)
Area_convex <- st_sf(st_drop_geometry(landIQ_clip2bats_4326_points),
geom = geom_convex,
crs = st_crs(4326)
)
ggplot() +
geom_sf(data = geom_convex)
landIQ_clip2bats_4326_simple <- landIQ_clip2bats_4326 %>%
st_simplify(TRUE, dTolerance = 50) %>%
st_cast("MULTIPOLYGON") %>%
st_coordinates()
landIQ_clip2bats_4326_simple <- landIQ_clip2bats_4326 %>%
st_cast("MULTIPOLYGON") %>%
st_coordinates()
landIQ_clip2bats_4326_points <- st_as_sf(landIQ_clip2bats_4326_simple %>% as.data.frame(), coords = c("X","Y"), remove = FALSE)
library(concaveman)
geom_convex <- concaveman(landIQ_clip2bats_4326_points)
Area_convex <- st_sf(st_drop_geometry(landIQ_clip2bats_4326_points),
geom = geom_convex,
crs = st_crs(4326)
)
ggplot() +
geom_sf(data = geom_convex)
library(rgee)
install.packages("rgee")
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(stars) # ʻstarsʻ requires 'sf' 0.9.8 was found, but >= 1.0.3
library(sf)
library(terra)
library(exactextractr)
# fveg from CALFIRE FRAP
# https://map.dfg.ca.gov/metadata/ds1327.html
# read into arcmap and then exported as a tif because had trouble reading the geodatabase in R
# create a new column that is equal to WHR13NAME except where WHRNUM has riparian values: 15 (Desert Riparian), 19, 37 (Montane Riparian), 56 (Valley Foothill Riparian)
# Use the Lookup tool to export the new column as a raster and read that in here
fveg <- rast("~/Documents/github/larsen-lab-bats/data/landcover_analysis/fveg/fveg_ReclassVegCode_NAD83.tif")
# Data IQ crop data from 2019 downloaded from https://data.cnra.ca.gov/dataset/statewide-crop-mapping
landIQ <- st_read("~/Documents/github/larsen-lab-bats/data/landcover_analysis/i15_Crop_Mapping_2019/i15_Crop_Mapping_2019.shp") %>%
st_transform(st_crs(3310)) %>%  # project into NAD83 / California Albers projection
st_make_valid()
bat_study_area_4326 <- bat_study_area %>%
st_transform(st_crs(4326))
download.file("https://drive.google.com/uc?export=download&id=1Iyk7XhPHY5rs4OLI56b3GHibZIPdDnpo",
destfile = "Areas.zip",
mode = "wb"
)
unzip("Areas.zip", exdir = ".")
Areas <- st_read("Areas.gpkg")
#> Simple feature collection with 6 features and 1 field
#> Geometry type: MULTIPOLYGON
#> Dimension:     XY
#> Bounding box:  xmin: 272036.8 ymin: 432143.8 xmax: 288261.8 ymax: 446143.8
#> Projected CRS: OSGB 1936 / British National Grid
Area_1 <- Areas %>%
filter(name == "Area 1")
# Use concaveman
library(concaveman)
geom_convex <- concaveman(st_coordinates(Area_1)[, 1:2]) %>%
list() %>%
st_polygon() %>%
st_sfc()
Area_convex <- st_sf(st_drop_geometry(Area_1),
geom = geom_convex,
crs = st_crs(Areas)
)
plot(st_geometry(Area_convex), col = "red")
plot(st_geometry(Area_1), add = TRUE, border = "blue")
Area_1_simple <- Area_1 %>%
st_simplify(TRUE, dTolerance = 5000) %>%
st_cast("MULTIPOLYGON") %>%
st_coordinates()
bat_study_area <- st_read("~/Documents/github/larsen-lab-bats/data/landcover_analysis/bats/bats_study_area/bats_study_area.shp") %>%
st_transform(st_crs(3310)) %>%
st_make_valid()
bat_raw <- rast("~/Documents/github/larsen-lab-bats/data/landcover_analysis/bats/2017_aggregate_2017.tif") # WGS84 projection of the raw bats
bat_exp <- rast("~/Documents/github/larsen-lab-bats/data/landcover_analysis/bats/bats_exponential_corrected_2017.tif") # WGS84 projection of the exponentially corrected bat layer
bat_study_area_4326 <- bat_study_area %>%
st_transform(st_crs(4326))
# -122.4874 ymin: 37.86737 xmax: -120.8678 ymax: 39.13167
bat_raw_NAD83 <- project(bat_raw, "epsg:3310")
bat_exp_NAD83 <- project(bat_exp, "epsg:3310")
# Crop to bat study area
landIQ_clip2bats <- st_crop(landIQ, bat_study_area)
# Alternative code that does the same as the above chunk, just slightly slower and also adds a CropName column
SummerCropID_crosswalk <- read_csv("~/Documents/github/larsen-lab-bats/data/landcover_analysis/CSV_files/SummerCropID.csv")
landIQ_clip2bats_SummerCropID <- merge(landIQ_clip2bats, SummerCropID_crosswalk, by = "CROPTYP2")
# The buffering approach is kind of weird because youʻll be hard-pressed to find the sweet spot distance that covers the gap between fields but doesnʻt overlap too much
landIQ_clip2bats_SummerCropID_buff100 <- st_buffer(landIQ_clip2bats_SummerCropID, 100)
landIQ_buff100_summ <- landIQ_clip2bats_SummerCropID_buff100 %>%
summarise()
fveg_vect <- as.polygons(fveg, values = TRUE,extent=FALSE) # this converts the fveg rast to a SpatVect
fveg_sf <- sf::as_Spatial(sf::st_as_sf(stars::st_as_stars(fveg), as_points = FALSE, merge = T)) %>%
st_as_sf() %>%
st_make_valid()
fveg_rmv_landIQ_buff100_summ <- st_difference(st_make_valid(fveg_sf), st_make_valid(landIQ_buff100_summ))
st_write(landIQ_clip2bats_SummerCropID, "~/Documents/github/larsen-lab-bats/data/landcover_analysis/output_layers/landIQ_clip2bats_SummerCropID.gpkg", overwrite = T)
landIQ_clip2bats_newcode <- st_read("~/Documents/bat_temp/output_layers/qgis_analysis/landIQ_clip2bats_NewCode.gpkg") %>%
st_transform(st_crs(3310)) %>%  # project into NAD83 / California Albers projection
st_make_valid()
fveg_rmv_landIQbuff100 <- st_read("~/Documents/bat_temp/output_layers/qgis_analysis/fveg_rmv_landIQbuff100m.gpkg") %>%
st_transform(st_crs(3310)) %>%  # project into NAD83 / California Albers projection
st_make_valid()
ag_field_spaces_100m_buff <- st_read("~/Documents/bat_temp/output_layers/qgis_analysis/ag_field_spaces_100m_buff.gpkg") %>%
st_transform(st_crs(3310)) %>%  # project into NAD83 / California Albers projection
st_make_valid()
landIQ_newcode <- landIQ_clip2bats_newcode %>%
dplyr::select(NewCode)
fveg_newcode <- fveg_rmv_landIQbuff100 %>%
dplyr::select(NewCode)
ag_spaces_newcode <- ag_field_spaces_100m_buff %>%
dplyr::select(NewCode)
land_combine_newcode_sf <- do.call("cbind", c(fveg_newcode, landIQ_newcode, ag_spaces_newcode))
land_combine_newcode_sf <- do.call("rbind", list(fveg_newcode, landIQ_newcode, ag_spaces_newcode))
View(landIQ_newcode)
summary(land_combine_newcode_sf$NewCode %>% as.factor())
LC_newcode_labels <- read_csv("~/Documents/github/larsen-lab-bats/data/landcover_analysis/CSV_files/newcode_labels.csv")
lc_newcode_label_sf <- merge(x = land_combine_newcode_sf, y = LC_newcode_labels, by.x = "NewCode", by.y = "NewCode")
summary(lc_newcode_label_sf$NewClass %>% as.factor())
st_crs(lc_newcode_label_sf)
st_crs(bat_raw_NAD83)
# While it comes at the cost of adding another package (exactextractr), the exact_extract function is built to perform faster and to account for partial overlap of polygons with raster cells
extract_rawbats_zonalstats <-  exact_extract(bat_raw_NAD83, lc_newcode_label_sf, fun = c('mean', 'stdev'))
st_crs(bat_exp_NAD83)
st_crs(lc_newcode_label_sf)
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(stars) # ʻstarsʻ requires 'sf' 0.9.8 was found, but >= 1.0.3
library(sf)
library(terra)
library(exactextractr)
library(nngeo)
# Data IQ crop data from 2019 downloaded from https://data.cnra.ca.gov/dataset/statewide-crop-mapping
landIQ <- st_read("~/Documents/github/larsen-lab-bats/data/landcover_analysis/i15_Crop_Mapping_2019/i15_Crop_Mapping_2019.shp") %>%
st_transform(st_crs(3310)) %>%  # project into NAD83 / California Albers projection
st_make_valid()
gc()
